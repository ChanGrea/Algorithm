## STL

> `Standard Template Library`의 약자로서, 알고리즘, 컨테이너, 함수, 이터레이터 등으로 이루어져있다.

오랫동안 검증된 효율적이고 안정적인 라이브러리다.

자주 쓰이는 STL에 대해서 정리하고자 한다.

<br>

## 자주 쓰이는 STL

### :point_right: Vector

#### 설명

- 배열과 비슷하지만, 크기가 가변적이다.
- Iterator 지원


#### 예시 코드

```c++
#include <vector> // vector 를 물려서 사용
int main() {
    // 생성 방법
    vector<int> v1;
    vector<int> v2(6, 1);
    vector<int> v3 = {1, 2, 3, 4, 5};

    // .push_back(' ') 을 사용하면 가장 뒤에 데이터를 추가 할 수 있다.
    vector<int> a = {1, 2, 3, 4, 5};
    a.push_back(6); // [1, 2, 3, 4, 5, 6]
    a.push_back(7); // [1, 2, 3, 4, 5, 6, 7]
    
    // .pop_back() 은 가장 뒤의 데이터를 꺼내온다.
    a.pop_back(); // [1, 2, 3, 4, 5, 6]

    // 배열 비우기
    a.clear(); // []

    // 배열의 길이.. 주로 루프를 돌릴 때 유용
    a.size();

    // 배열처럼 인덱스를 사용해서 자료 접근 가능
    for (int i=0; i < a.size(); i++) {
        cout << a[i] << ' ';
    }

    // a.begin(), a.end()를 입력하면 iterator 가 반환된다. sort 라이브러리를 쓸 때 유용
    for (vector<int>::iterator it = a.begin(); it != a.end(); ++it) {
        cout << *it << ' ';
    }

    return 0; 
}
```

### :point_right: Pair

#### 설명

- 두 자료형을 하나의 쌍(Pair)으로 묶을 때 사용
- 첫 번째 데이터는 `first`, 두 번째 데이터는 `second`로 접근

#### 예시 코드

```c++
#include <vector>

pair<int, int> p1;
cout << p1.first << ' ' << p1.second << '\n'; // 0 0 출력
p1 = make_pair(1, 2);
cout << p1.first << ' ' << p1.second << '\n'; // 1 2 출력

// Pair 속에 Pair 를 중첩해서 사용 가능
pair<pair<int,int>, pair<int,int>>  p =
make_pair(make_pair(1,2), make_pair(3,4));

cout << p.first.first << ' ' << p.first.second << ' '; 
cout << p.second.first << ' ' << p.second.second << '\n'; // 1 2 3 4 출력
```

### :point_right: Set

#### 설명

- Associative 컨테이너(?)로 균형 이진 트리로 구현되어있다.
- Key라 불리는 원소들의 집합으로 이루어져 있다.
- **Key값은 중복되지 않는다!**
- `insert`를 통해 입력하면 **자동 정렬**된다
- 즉, <u>중복을 피하면서 정렬까지 사용하고 싶으면 매우 유용</u>

#### 예시 코드

```c++
#include <iostream>
#include <set> 

int main () {
    set<int> s;

    s.insert(10);
    s.insert(30);
    s.insert(50);
    s.insert(20);
    s.insert(40);
    s.insert(60);

    set<int>::iterator it;
    
    s.insert(10); // 중복 불가

    for (it = s.begin(); it != s.end(); ++it) {
        cout << *it << " "; // 10 20 30 40 50 60 출력
    }

    // 값 존재 여부 확인
    it = s.find(30);
    if ( it != s.end() ) {
        cout << *it << " 존재" << endl;
    } else {
        cout << "존재하지 않음" << endl;
    }

    return 0;
}
```

### :point_right: Map

#### 설명

- Associative 컨테이너
- set은 원소값으로 key 하나만을 저장하지만, map은 `<key, value>`의 쌍(pair)으로 저장
- **중복 저장되지 않는다!**
- set처럼 컨테이너에 원소 (key, value의 쌍)를 삽입하는 멤버 함수 `insert()`를 제공.
- map은 [] 연산자를 제공하여 key에 해당하는 원소의 value에 쉽게 접근하거나 변경할 수 있다.

#### 예시 코드

```c++
#include <iostream>
#include <map>
using namespace std;

int main(){

    map<int, int> m;

    //pair 객체 insert()
    m.insert(pair<int, int>(5, 100));
    m.insert(pair<int, int>(3, 100)); 
    pair<int, int> p(9, 50);     
    m.insert(p);                

    // [] 연산자로 key/value 삽입
    m[11] = 200;            
    m[12] = 200;
    m[13] = 40;

    map<int, int>::iterator iter;
    for (iter = m.begin(); iter != m.end(); ++iter)
        cout << "<" << (*iter).first << "," << (*iter).second << ">" << " ";
    cout << endl;
    // 출력 <3,100> <5,100> <9,50> <11,200> <12,200> <13,40>

    // [] 연산자로 key/value 갱신 가능
    m[13] = 140;        

    pair<map<int, int>::iterator, bool > pr;

    // 중복 데이터 삽입 불가
    pr = m.insert(pair<int, int>(10, 30));
    if (true == pr.second)
        cout << "key : " << pr.first->first << ", value : " << pr.first->second << " 저장 완료!" << endl;
    else
        cout << "key 10가 이미 m에 있습니다." << endl;

    return 0;
}
```

### :point_right: Stack

#### 설명

- LIFO(Last In First Out)

#### 예시 코드

```c++
#include <iostream>
#include <stack>

using namespace std;

int main () {
    stack<int> s;
    s.push(6);
    s.push(4);
    s.push(1);
    s.pop();
    s.push(3);
    s.push(10);
    s.pop();
    s.push(11);

    while ( !s.empty()) {
        cout << s.top() << ' ';
        s.pop();
    }

    //empty() : 스택이 비어있으면 true 아니면 false를 반환
    //size() : 스택 사이즈를 반환
    return 0;
}
```

### :point_right: Queue

#### 설명

- FIFO(First In First Out)
- `BFS`에 많이 사용

#### 예시 코드

```c++
#include <iostream>
#include <queue>

using namespace std;

int main () {
    queue<int> q;
    q.push(6);
    q.push(4);
    q.push(1);
    q.pop();
    q.push(3);
    q.push(10);
    q.pop();
    q.push(11);

    while (!q.empty())
    {
        cout << q.front() << ' ';
        q.pop();
    }

    return 0;
}
```

### :point_right: Priority Queue

#### 설명

- 들어간 순서와 상관없이 **우선순위가 높은** 데이터가 먼저 나온다.
- 내부적으로 의 `heap` 과 관련된 함수들을 사용하여 구현

#### 예시 코드

```c++
#include <iostream>
#include <queue>

using namespace std;

int main(){

    // priority_queue
    priority_queue< int, vector<int>, less<int> > pq;

    // push(element)
    pq.push(5);
    pq.push(2);
    pq.push(8);
    pq.push(9);
    pq.push(1);
    pq.push(14);

    // pop()
    pq.pop();
    pq.pop();

    // top();
    cout << "pq top : " << pq.top() << '\n';

    // empty(), size()
    if(!pq.empty()) cout << "pq size : " << pq.size() << '\n';

    // pop all
    while(!pq.empty()){
        cout << pq.top() << " ";
        pq.pop();
    }

    cout << '\n';

    return 0;
}
```

### :point_right: Bitset

#### 설명

- 비트 연산에 유용

#### 예시 코드

```c++
#include <iostream>
#include <string>
#include <bitset>
#include <algorithm>

using namespace std;

int main() {
    bitset<100000> a(76),b(44); // 각각 76, 44의 비트가 입력됨
    cout << (a & b) << '\n';
    cout << (a | b) << '\n';
    cout << (a ^ b) << '\n';
    cout << (~a) << '\n';
    cout << (~b) << '\n';
    return 0;
}
```

### :point_right: String

#### 설명


#### 예시 코드

```c++

```

### :point_right: Algorithm

#### count

#### find

#### fill

#### reverse

#### rotate

#### swap

#### sort

#### binary_search

#### min/max

<br>

## Reference

[https://purduecho.github.io/stl3/](https://purduecho.github.io/stl3/)